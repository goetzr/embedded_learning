# cortex-m-rt-macros Crate Notes

Provides the `entry`, `exception`, `interrupt`, and `pre_init` macros that must annotate these special functions.

## entry Macro

The entry point function must be annotated with the `entry` attribute. The `entry` attribute, implemented by the `entry` macro, performs the following processing:

1. Checks the signature of the function to ensure it's valid. The entry point function must:
    - Take no parameters
    - Never return (-> !)
2. Checks to ensure all attributes on the function are permitted. The permitted attributes are:
    - doc
    - link_section
    - cfg
    - allow
    - warn
    - deny
    - forbid
    - cold
    - naked
3. Renames the function by prepending `__cortex_m_rt_` to the function name. This function is termed the entry point function.
4. Creates a new function that calls the entry point function. This new function, termed the trampoline function, has the same name as the entry point function with `_trampoline` appended. The trampoline function is the actual entry point to the binary, exported with a name of `main`.

A well-formed entry point function and the code generated by the `entry` macro is shown below.

```rust
// **********************************
// User-written entry point
// **********************************

#[entry]
fn my_entry_point() -> ! {
    loop {
        ...
    }
}

// **********************************
// Code generated by entry macro
// **********************************

// Renamed entry point function.
fn __cortex_m_rt_my_entry_point() -> ! {
    loop {
        ...
    }
}

// Trampoline function.
#[export_name = "main"]
pub unsafe extern "C" fn __cortex_m_rt_my_entry_point_trampoline() {
    __cortex_m_rt_my_entry_point()
}
```

5. If the entry point function begins by declaring mutable static variables, these declarations are moved to the trampoline function, which then passes mutable references to them into the entry point function.

```rust
// ******************************
// User-written entry point
// ******************************

#[entry]
fn my_entry_point() -> ! {
    // Declare mutable static variable at start of function.
    static mut DATA: i32 = 27;

    loop {
        ...
        unsafe { DATA += 1; }
        ...
    }
}

// **********************************
// Code generated by entry macro
// **********************************

// Renamed entry point function.
// Mutable static variable received as mutable reference parameter.
fn __cortex_m_rt_my_entry_point(DATA: &'static mut i32) -> ! {
    loop {
        ...
        unsafe { DATA += 1; }
        ...
    }
}

// Trampoline function.
// Mutable static data declarations moved to this function.
// Mutable reference to static data passed to entry point function.
#[export_name = "main"]
pub unsafe extern "C" fn __cortex_m_rt_my_entry_point_trampoline() {
    __cortex_m_rt_my_entry_point(
        { static mut DATA: i32 = 27; &mut DATA }
    )
}
```

## exception Macro

An exception handler function must be annotated with the `exception` attribute. The `exception` attribute, implemented by the `exception` macro, performs the following processing:

1. Checks to ensure all attributes on the function are permitted. The permitted attributes are:
    - doc
    - link_section
    - cfg
    - allow
    - warn
    - deny
    - forbid
    - cold
    - naked
2. Checks to ensure the function name matches the name of a valid Cortex-M exception. The permitted exception handler function names are listed below. All processors support *DefaultHandler*, *HardFault*, and *NonMaskableInt*. If defining a handler for one of the other exceptions, check your target processor to ensure it's supported. **NOTE:** The `exception` macro emits code that creates an unused reference to the exception handler. If your target processor does not support the exception, a compiler error will be emitted.
    - DefaultHandler
    - HardFault
    - NonMaskableInt
    - MemoryManagement
    - BusFault
    - UsageFault
    - SecureFault
    - SVCall
    - DebugMonitor
    - PendSV
    - SysTick
3. Checks the safety of the function. The following exception handlers must be marked unsafe:
    - DefaultHandler
    - HardFault
    - NonMaskableInt

The remaining processing performed by the `exception` macro is specific to the exception handler being defined.

### DefaultHandler

1. Checks the signature of the function to ensure it's valid. The function must:
    - Take a single argument of type `i16`, which gets passed the IRQ number of the currently executing exception. **NOTE:** The IRQ number is equal to the exception number minus 16.
    - Never return (-> !) or return nothing (return type omitted or -> ())
2. Renames the function by prepending `__cortex_m_rt_` to the function name. This function is termed the exception handler function.
3. Creates a new function that calls the exception handler function. This new function, termed the trampoline function, has the same name as the exception handler function with `_trampoline` appended. The trampoline function is exported with the name of the exception being handled (`DefaultHandler` in this case).

A well-formed DefaultHandler function and the code generated by the `exception` macro is shown below.

```rust
// **************************************
// User-written DefaultHandler function
// **************************************

// It makes sense for the default handler to never return.
#[exception]
unsafe fn DefaultHandler(irqn: i16) -> ! {
    loop {
        ...
    }
}

// **************************************
// Code generated by exception macro
// **************************************

unsafe fn __cortex_m_rt_DefaultHandler(irqn: i16) -> ! {
    loop {
        ...
    }
}

#[export_name = DefaultHandler]
pub unsafe extern "C" fn __cortex_m_rt_DefaultHandler_trampoline() {
    extern crate core;

    const SCB_ICSR: *const u32 = 0xE000_ED04 as *const u32;

    let irqn = unsafe {
        (core::ptr::read_volatile(SCB_ICSR) & 0x1FF) as i16 - 16
    };

    __cortex_m_rt_DefaultHandler(irqn)
}
```

### HardFault

1. Checks the signature of the function to ensure it's valid. The function must:
    - Take a single argument which gets passed a shared reference to the [exception frame](https://docs.rs/cortex-m-rt/latest/cortex_m_rt/struct.ExceptionFrame.html)
    - Never return (-> !) or return nothing (return type omitted)
2. Renames the function by prepending `__cortex_m_rt_` to the function name. This function is termed the exception handler function.
3. Creates a new function that calls the exception handler function. This new function, termed the trampoline function, has the same name as the exception handler function with `_trampoline` appended. The trampoline function is exported with the name of the exception being handled (`HardFault` in this case). The trampoline function is located in the special `.HardFault.user` section of the binary.

A well-formed HardFault function and the code generated by the `exception` macro is shown below.

```rust
// **************************************
// User-written HardFault function
// **************************************

// It makes sense for the hard fault handler to never return.
#[exception]
unsafe fn HardFault(frame: &ExceptionFrame) -> ! {
    loop {
        ...
    }
}

// **************************************
// Code generated by exception macro
// **************************************

unsafe fn __cortex_m_rt_HardFault(frame: &ExceptionFrame) -> ! {
    loop {
        ...
    }
}

#[export_name = "HardFault"]
// Only emit link_section when building for embedded targets,
// because some hosted platforms (used to check the build)
// cannot handle the long link section names.
#[cfg_attr(target_os = "none", link_section = ".HardFault.user")]
pub unsafe extern "C" fn __cortex_m_rt_HardFault_trampoline(
    frame: &::cortex_m_rt::ExceptionFrame)
{
    __cortex_m_rt_DefaultHandler(frame)
}
```

### All Other Exceptions

1. Checks the signature of the function to ensure it's valid. The function must:
    - Take no arguments
    - Never return (-> !) or return nothing (return type omitted or -> ())
2. Renames the function by prepending `__cortex_m_rt_` to the function name. This function is termed the exception handler function.
3. Creates a new function that calls the exception handler function. This new function, termed the trampoline function, has the same name as the exception handler function with `_trampoline` appended. The trampoline function is exported with the name of the exception being handled.

A well-formed SVCall function and the code generated by the `exception` macro is shown below.

```rust
// **************************************
// User-written SVCall function
// **************************************

// The exception macro doesn't enforce this function being unsafe,
// but more than likely the implementation will be unsafe.
#[exception]
unsafe fn SVCall() {
    ...
}

// **************************************
// Code generated by exception macro
// **************************************

unsafe fn __cortex_m_rt_SVCall() {
    ...
}

#[export_name = "SVCall"]
pub unsafe extern "C" fn __cortex_m_rt_SVCall_trampoline() {
    __cortex_m_rt_SVCall()
}
```

4. If the exception handler function begins by declaring mutable static variables, these declarations are moved to the trampoline function, which then passes mutable references to them into the exception handler function. This is handled in the same manner as for the entry point function. See the `entry` macro above for details.

    - **NOTE:** The once difference from the `entry` macro is that the entry function associates a lifetime of `'static` with the passed reference. No lifetime is associated with the reference passed to the exception handler function.

## interrupt Macro

An interrupt service routine (ISR) function must be annotated with the `interrupt` attribute. The `interrupt` attribute, implemented by the `interrupt` macro, performs the following processing:

1. Checks the signature of the function to ensure it's valid. The function must:
    - Take no arguments
    - Never return (-> !) or return nothing (return type omitted or -> ())
2. Renames the function by prepending `__cortex_m_rt_` to the function name. This function is termed the ISR function. The original function name is termed the interrupt name.
3. Creates a new function that calls the ISR function. This new function, termed the trampoline function, has the same name as the ISR function with `_trampoline` appended. The trampoline function is exported with the interrupt name.
4. Generates code at the start of the ISR function that references the interrupt name (`stm32f3::stm32f303::interrupt::<interrupt name>`). If the interrupt does not exist, a compiler error is emitted.
5. Checks to ensure all attributes on the function are permitted. The permitted attributes are:
    - doc
    - link_section
    - cfg
    - allow
    - warn
    - deny
    - forbid
    - cold
    - naked

A well-formed ISR function and the code generated by the `interrupt` macro is shown below.

```rust
// **************************************
// User-written ISR function
// **************************************

#[interrupt]
fn USART1_EXTI25() {
    ...
}

// **************************************
// Code generated by interrupt macro
// **************************************

fn __cortex_m_rt_USART1_EXTI25() {
    ...
}

#[export_name = "USART1_EXTI25"]
pub unsafe extern "C" fn __cortex_m_rt_USART1_EXTI25_trampoline() {
    __cortex_m_rt_USART1_EXTI25()
}
```

6. If the ISR function begins by declaring mutable static variables, these declarations are moved to the trampoline function, which then passes mutable references to them into the ISR function. This is handled in the same manner as for the entry point function. See the `entry` macro above for details.

    - **NOTE:** The once difference from the `entry` macro is that the entry function associates a lifetime of `'static` with the passed reference. No lifetime is associated with the reference passed to the ISR function.

## pre_init Macro

If you need to run code at the beginning of the reset handler, before your entry point and before memory has been initialized, this function must be annotated with the `pre_init` attribute. Any access of memory in this function is undefined behavior. Users are advised to only use the `pre_init` attribute when absolutely necessary. The `pre_init` attribute, implemented by the `pre_init` macro, performs the following processing:

1. Checks the signature of the function to ensure it's valid. The function must:
    - Marked unsafe
    - Take no arguments
    - Never return (-> !) or return nothing (return type omitted or -> ())
2. Checks to ensure all attributes on the function are permitted. The permitted attributes are:
    - doc
    - link_section
    - cfg
    - allow
    - warn
    - deny
    - forbid
    - cold
    - naked

A well-formed pre_init function and the code generated by the `pre_init` macro is shown below.

```rust
// **************************************
// User-written pre_init function
// **************************************

#[pre_init]]
unsafe fn my_pre_init() {
    ...
}

// **************************************
// Code generated by pre_init macro
// **************************************

#[export_name = "__pre_init"]
pub unsafe fn my_pre_init() {
    ...
}
```
